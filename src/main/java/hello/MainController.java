package hello;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.Random;
import java.lang.String;
import java.lang.Long;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import java.nio.charset.Charset;
import java.util.Arrays;

import hello.Dsm;
import hello.DsmRepository;
import hello.Token;
import hello.TokenRepository;
import hello.AESEncryption;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/demo", produces = "application/json") // This means URL's start with /demo (after Application path)
public class MainController {
	@Autowired // This means to get the bean called userRepository
	           // Which is auto-generated by Spring, we will use it to handle the data
	private DsmRepository dsmRepository;
	
	@Autowired
	
	private TokenRepository tokenRepository;

	@GetMapping(path="/tokenise") // Map ONLY GET Requests
	public @ResponseBody Token addNewToken (@RequestParam String card) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		AESEncryption obj = new AESEncryption();
		Dsm d = new Dsm();
		String token = "";
    	Random rand = new Random();
    	char[] ch=card.toCharArray();
    	String passkey = "secret";

    	String lastfour = card.substring(card.length()-4);
    	
    	if(card.length()>=11 && card.length()<=16)
		{
			while(true)
			{
				for(int i=0;i<card.length();i++)
				{
					if(ch[i]<'0' || ch[i]>'9')
					{
						Token t = new Token("Error, Card should contain only numbers", card, lastfour);
						return t;
					}
					int c = rand.nextInt(9) + 48;
					token+=(char)c;
				}
				Token tmp = tokenRepository.findOne(token);
				if(tmp==null)
					break;
				else
					token = "";
			}
			

			byte[] cipherText = null;
			SecretKey secKey  = null;
			try
			{
				secKey = obj.getSecretEncryptionKey();
			} catch (Exception e) {
 				e.printStackTrace();
			}
			try
			{
				cipherText = obj.encryptText(card, secKey);
			} catch (Exception f) {
 				f.printStackTrace();
			}
			
			passkey = obj.bytesToHex(secKey.getEncoded());
			String enc_card = obj.bytesToHex(cipherText);

			enc_card += lastfour;
			Token t = new Token(token, enc_card, lastfour);
			tokenRepository.save(t);

			d.setToken(token);
			d.setPasskey(passkey);
			dsmRepository.save(d);
			return t;
		}
		
		Token t = new Token("Error, Card length should be 11 to 16", card, lastfour);
		return t;
	}

	@GetMapping(path="/detokenise") // Map ONLY GET Requests
	public @ResponseBody Token getToken (@RequestParam String token) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		Token t = tokenRepository.findOne(token);
		String card = t.getCard();	
		card = card.substring(0, card.length()-4);
		Dsm d = dsmRepository.findOne(token);
		String passkey = d.getPasskey();
		//System.out.println("Key picked from dsm: " + passkey);

		AESEncryption obj = new AESEncryption();
		// decode the base64 encoded string
		byte[] decodedKey = obj.hexToBytes(passkey);
		//System.out.println("Byte array: " + Arrays.toString(decodedKey));
		// rebuild key using SecretKeySpec
		SecretKey secKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
		//System.out.println("AES Key (Hex Form) picked from dsm and converted to secret key:"+obj.bytesToHex(secKey.getEncoded()));
		String decryptedText = "88888888888";
		try
			{
				byte[] cipher = obj.hexToBytes(card);
        		decryptedText = obj.decryptText(cipher, secKey);
				
			} catch (Exception e) {
 				e.printStackTrace();
			} 

		Token ans = new Token(token, decryptedText, decryptedText.substring(decryptedText.length()-4));
		return ans;
	}

	@GetMapping(path="/delete") // Map ONLY GET Requests
	public @ResponseBody String deleteToken (@RequestParam String token) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request
	
		tokenRepository.delete(token);
		return "Deleted";
	}

	@GetMapping(path="/all")
	public @ResponseBody Iterable<Token> getAllTokens() {
		// This returns a JSON or XML with the users
		return tokenRepository.findAll();
	}


	
}package hello;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.Random;
import java.lang.String;
import java.lang.Long;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import java.nio.charset.Charset;
import java.util.Arrays;

import hello.Dsm;
import hello.DsmRepository;
import hello.Token;
import hello.TokenRepository;
import hello.AESEncryption;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/demo", produces = "application/json") // This means URL's start with /demo (after Application path)
public class MainController {
	@Autowired // This means to get the bean called userRepository
	           // Which is auto-generated by Spring, we will use it to handle the data
	private DsmRepository dsmRepository;
	
	@Autowired
	
	private TokenRepository tokenRepository;

	@GetMapping(path="/tokenise") // Map ONLY GET Requests
	public @ResponseBody Token addNewToken (@RequestParam String card) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		AESEncryption obj = new AESEncryption();
		Dsm d = new Dsm();
		String token = "";
    	Random rand = new Random();
    	char[] ch=card.toCharArray();
    	String passkey = "secret";

    	String lastfour = card.substring(card.length()-4);
    	
    	if(card.length()>=11 && card.length()<=16)
		{
			while(true)
			{
				for(int i=0;i<card.length();i++)
				{
					if(ch[i]<'0' || ch[i]>'9')
					{
						Token t = new Token("Error, Card should contain only numbers", card, lastfour);
						return t;
					}
					int c = rand.nextInt(9) + 48;
					token+=(char)c;
				}
				Token tmp = tokenRepository.findOne(token);
				if(tmp==null)
					break;
				else
					token = "";
			}
			

			byte[] cipherText = null;
			SecretKey secKey  = null;
			try
			{
				secKey = obj.getSecretEncryptionKey();
			} catch (Exception e) {
 				e.printStackTrace();
			}
			try
			{
				cipherText = obj.encryptText(card, secKey);
			} catch (Exception f) {
 				f.printStackTrace();
			}
			
			passkey = obj.bytesToHex(secKey.getEncoded());
			String enc_card = obj.bytesToHex(cipherText);

			enc_card += lastfour;
			Token t = new Token(token, enc_card, lastfour);
			tokenRepository.save(t);

			d.setToken(token);
			d.setPasskey(passkey);
			dsmRepository.save(d);
			return t;
		}
		
		Token t = new Token("Error, Card length should be 11 to 16", card, lastfour);
		return t;
	}

	@GetMapping(path="/detokenise") // Map ONLY GET Requests
	public @ResponseBody Token getToken (@RequestParam String token) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		Token t = tokenRepository.findOne(token);
		String card = t.getCard();	
		card = card.substring(0, card.length()-4);
		Dsm d = dsmRepository.findOne(token);
		String passkey = d.getPasskey();
		//System.out.println("Key picked from dsm: " + passkey);

		AESEncryption obj = new AESEncryption();
		// decode the base64 encoded string
		byte[] decodedKey = obj.hexToBytes(passkey);
		//System.out.println("Byte array: " + Arrays.toString(decodedKey));
		// rebuild key using SecretKeySpec
		SecretKey secKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
		//System.out.println("AES Key (Hex Form) picked from dsm and converted to secret key:"+obj.bytesToHex(secKey.getEncoded()));
		String decryptedText = "88888888888";
		try
			{
				byte[] cipher = obj.hexToBytes(card);
        		decryptedText = obj.decryptText(cipher, secKey);
				
			} catch (Exception e) {
 				e.printStackTrace();
			} 

		Token ans = new Token(token, decryptedText, decryptedText.substring(decryptedText.length()-4));
		return ans;
	}

	@GetMapping(path="/delete") // Map ONLY GET Requests
	public @ResponseBody String deleteToken (@RequestParam String token) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request
	
		tokenRepository.delete(token);
		return "Deleted";
	}

	@GetMapping(path="/all")
	public @ResponseBody Iterable<Token> getAllTokens() {
		// This returns a JSON or XML with the users
		return tokenRepository.findAll();
	}


	
}
